---
layout: post
title: Redis的AOF持久化
categories: Redis
description:
keywords: 数据库
---

# Redis的AOF 持久化

![](/images/posts/redis/12.png)

Redis 的持久化主要有两大机制，分别是 AOF 日志和 RDB 日志，这次我们主要聊聊 AOF 日志的实现。

# AOF日志写入流程

![](/images/posts/redis/13.png)

与传统数据库的写前日志机制（Write Ahead Log,WAL）不同，Redis是先执行命令，把数据写入到内存，然后才记录日志。

这种保存写操作命令到日志的持久化方式，就是Redis里的 AOF(Append Only File) 持久化功能。注意只会记录写操作命令，不会记录读操作命令，因为没有意义。

## AOF日志格式

AOF日志文件就是一个普通的文本文件，例如我们执行命令：set testkey testvalue ，AOF日志会写下

```
*3
$3
set
$7
testkey
$9
testvalue
```

其中「*3」代表当前命令有三部分组成，每部分都有「$+数组」开头，后面紧跟着具体的命令、键、值，“数字”表示这部分中命令、键、值一共有多少字节。

---

Redis 先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做有两个好处。

- 避免额外开销

  为了避免额外检查成本，Rdis在记录AOF日志时不会先进行语法检查。如果先记录日志再执行命令，可能导致错误命令被记录，从而在使用日志恢复数据时发生错误。

- 不阻塞当前主进程

  由于Redis执行更新内存、写入日志这两个操作都是在主线程中进行的，因此通过先更新内存，再写入日志的方式，不阻塞当前主进程。


而AOF(Append Only File) 持久化方式，同样会带来两个风险：

1. 假如Redis执行更新内存后，还没来得及写入日志，此时发生了宕机事件，就会导致数据丢失。
2. 由于写操作命令执行成功后才记录到AOF日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险。

---

通过分析可以发现，以上两个风险都跟「AOF写回磁盘的时机」相关，因此通过控制落盘时机，可以有效解除风险。

# 三种写回策略

AOF 机制给我们提供了三个选择，也就是AOF配置项 appendfsync 的三个可选值。

- Always 同步写回：每个命令执行完后，立马同步到磁盘日志。
- Everysec 每秒写回：每执行一次命令，先把日志写到AOF文件的缓冲区，每隔一秒把缓冲区中的数据写入到磁盘中。
- No 操作系统控制写回：每执行一次命令，都把日志写到AOF文件的缓冲区中，至于何时落盘，由操作系统自行控制。

通过以上分析可以发现，这三种写回策略都无法做到两全其美，因此具体要选择哪种策略，需要根据业务系统的特性进行取舍。

![](/images/posts/redis/14.png)

# AOF重写机制

AOF的重写机制，简单理解就是对旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。

用一张图举个例子：

![](/images/posts/redis/15.png)

AOF文件按追加方式记录写命令，当键值对被多次修改时，AOF会记录多条命令。但在重写时，根据键值对的最新状态生成一条写入命令，使得在重写日志中每个键值对只需一条命令。在日志恢复时，执行此命令即可完成键值对的写入。

## AOF重写会阻塞吗？

AOF日志的重写过程，是由后台线程 bgrewriteaof 来完成的，可以避免阻塞主线程，导致性能下降。

![](/images/posts/redis/16.png)

每次执行重写时，主线程会 fork 出一个后台的 bgrewriteaof 子进程，然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，把数据写成操作命令，记入AOF重写日志中。同时，在重写的过程中，主进程会把在重写期间生成的新操作命令，写入AOF重写日志中，以保证数据库最新状态的记录。等待重写完成后，就可以用新的AOF文件替代旧文件了。