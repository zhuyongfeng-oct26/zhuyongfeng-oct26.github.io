---
layout: post
title: 短连接设计
categories: project-design
description:
keywords: 项目设计
---

# 短连接设计

![](/images/posts/project_design/07.png)

# 什么是短链？

首先举一个例子说明什么是短链。

现在我有一遍博客的URL地址是：[https://zhuyongfeng-oct26.github.io/2023/01/01/redis-lose](https://zhuyongfeng-oct26.github.io/2023/01/01/redis-lose) (57字符)

我可以通过在线的免费工具将其生成一条短链接：[https://a.d4t.cn/nQLRmE](https://a.d4t.cn/nQLRmE) (23字符)

![](/images/posts/project_design/08.png)

既然两条地址都能访问到同一个站点，那为什么还要生成短链接呢？**使用短链接的好处：更加简洁、便于使用、节省成本。**

- 更加简洁

  有些文章的链接很长，不利于记忆、复制，转换成字符较少的短链接会显得很简洁。

- 便于使用

  有些平台内发布内容的长度有限制（早期微博只能发最多140个字），通过把长链接转换成短连接后，可以节省出更多的空间来添加其他内容。另外，通过短链接转换的二维码会更容易识别。

- 节省成本

  通常我们在搞优惠活动时，都会把网站链接附带在短信内容里，发送到用户的手机上。而短信是按长度计费的，使用短链接可以节省成本。


# 实现短链的原理

我们在浏览器打开控制台后，访问 [https://a.d4t.cn/nQLRmE](https://a.d4t.cn/nQLRmE) ，可以看到会返回一个302 Found,同时返回的地址正是我们转换前的原始链接。

![](/images/posts/project_design/09.png)

---

短链接的原理其实就是：

- 将原始链接通过某种方式生成一个短链接
- 访问短链接时，实际访问的是短链接服务，然后根据短链接查询出原始链接
- 重定向跳转

## 哈希算法

哈希算法的作用就是：对任意一组数据进行计算，得到一个固定长度的字符串。常见的哈希算法有MD5、SHA-1、SHA-256、CRC32、MurmurHash算法。对于短链接场景，我们不需要关注保密性，只需要关注性能和分布特性，因此采用非加密哈希算法 MurmurHash .

例如以下例子：通过MurmurHash哈希算法运算得到：2803404692

![](/images/posts/project_design/10.png)

在得到运算结果之后，再使用62进制算法进行转换，获得字符串：33INCI，使用62进制进行转换，得到的结果是数字 + 大小写字母，这样更符合URL的规范。

## ID自增

对应原始的长链接，我们可以为其生成一个唯一ID，将长链接与唯一ID绑定起来，把这个唯一ID当成短链接，同时可以通过上面介绍到的62进制转换方式，把这个唯一ID的长度缩短并转换成数字+大小写字母组合。

那么还有一个问题是：如何设计一个全局唯一的ID发号器？

### MySQL自增ID

通过完全依赖DB主键自增的方式，是最常用的ID生成方法，适用于单体应用。但是在这种方式下，一旦发生了高并发的场景就会存在性能问题。

要解决这个问题，可以通过批量发号的方法解决。

![](/images/posts/project_design/11.png)

先提前为每台机器发放一个区间的号码，然后由各机器在内存中完成发号并自增，以此减少对DB的依赖，在区间号码消耗完之后，再批量写入数据库，并重新申请新的区间号码。但是这种方式只适用于单体架构，在分布式场景下，使用MySQL的自增，会存在不同DB主键冲突的问题。

**优点：**

- 简单方便

缺点：

- 只适用于单体应用
- 整体性能吞吐量较低

### Redis自增ID

Redis单机可以支撑10W+的请求，但如果作为发号器，还需要考虑持久化和灾备的问题。

通过使用Redis的INCR/INCRBY自增原子操作命令，能保证生成的ID肯定是唯一有序的，但是在高并发场景下，分布式自增主键的性能，没有本地生产ID的性能高。

优点：

- 整体性能吞吐量高

缺点：

- Redis集群宕机后，有可能会丢失最新ID的风险。

### Snowflake(雪花算法)

雪花算法是一种用于生成唯一ID的分布式算法，它在分布式系统中被广泛应用。雪花算法的原理是使用64位Long类型，按照一定的规则进行填充：时间(毫秒级)+集群ID+机器ID+序列号。

![](/images/posts/project_design/12.png)

优点：

- 高性能、低延迟、去中心化、按时间整体有序

缺点：

- 要求机器时钟同步，同时要解决时钟回拨的问题