---
layout: post
title: 数据库和缓存如何保证一致性？
categories: Redis
description:
keywords: 数据库
---

# 数据库和缓存如何保证一致性？

![](/images/posts/redis/03.png)

先介绍一种最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern

- 读取数据的时候，先查询缓存，若查询不到则读取数据库，然后写入缓存中，同时返回响应。
- 更新数据时，先更新数据库，然后再删除缓存旧值，返回响应。

每当随着业务量的增长，首先达到性能瓶颈的往往是数据库，通常在这时候都会接入缓存，以此降低数据库的压力。但引入缓存之后，就会面临一个问题，就是在业务操作出现并发时，如何保证缓存与数据库中数据的一致性呢？让我们带着这个疑问接着讨论吧。

# 常见的四种方式

线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：

## 先更新数据库，再更新缓存

1. 线程A更新数据库（X=1）
2. 线程B更新数据库（X=2）
3. 线程B更新缓存（X=2）
4. 线程A更新缓存（X=1）

最终X的值在缓存中是1，在数据库中是2，发生不一致。

![](/images/posts/redis/04.png)

## 先更新缓存，再更新数据库

1. 线程A更新缓存（X=1）
2. 线程B更新缓存（X=2）
3. 线程B更新数据库（X=2）
4. 线程A更新数据库（X=1）

最终X的值在缓存中是2，在数据库中是1，发生不一致。

![](/images/posts/redis/05.png)

可以发现，无论是采用先更新数据库，再更新缓存，或者是先更新缓存，再更新数据库的方式，都会发现数据不一致的情况。那如果在数据更新时，不再对缓存进行更新，而是删除的话呢？

写策略的步骤：

- 更新数据库中的数据；
- 删除缓存；

读策略的步骤：

- 如果读取能命中缓存，则直接返回数据；
- 如果读取不能命中缓存，则读取数据库，然后写入缓存中，同时返回数据；

## 先删除缓存，再更新数据库

1. 线程A删除缓存
2. 线程B查询缓存失败
3. 线程B读取数据库，并更新缓存（X=1）
4. 线程A更新数据库（X=2）

最终X的值在缓存中是1，在数据库中是2，发生不一致。

![](/images/posts/redis/06.png)

## 先更新数据库，再删除缓存

1. 线程A查询缓存，未命中
2. 线程A查询数据库（X=1）
3. 线程B更新数据库（X=2）
4. 线程B删除缓存
5. 线程A更新缓存（X=1）

最终X的值在缓存中是1，在数据库中是2，发生不一致。

![](/images/posts/redis/07.png)

根据以上的理论分析，我们会发现文章开头介绍的一种最经典的缓存+数据库读写的模式 Cache Aside Pattern 也是会出现数据不一致性的问题，**但是在实际中，这个问题出现的概率并不高**。

**因为缓存的写入通常要远远快于数据库的写入**，所以在实际中很难出现线程B已经更新了数据库并且删除了缓存，线程A才更新完缓存的情况。

所以，**「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的**。