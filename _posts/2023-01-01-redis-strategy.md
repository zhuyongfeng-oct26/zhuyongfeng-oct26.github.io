---
layout: post
title: Redis的过期删除策略和内存淘汰策略
categories: Redis
description:
keywords: 数据库
---

# Redis的过期删除策略和内存淘汰策略

![](/images/posts/redis/02.png)

# 过期淘汰策略

Redis通过运用过期淘汰策略，实现对超过过期时间的键值对进行删除（释放），以达到释放内存空间的目的。

## 如何设置过期时间？

Redis可以通过以下命令对键值对设置过期时间

```bash
# 设置key在seconds秒后过期
EXPIRE key seconds

# 设置key在milliseconds毫秒后过期
PEXPIRE key milliseconds

# 设置key在指定时间戳（秒）后到期
EXPIREAT key unix-time-seconds

# 设置key在指定时间戳（毫秒秒）后到期
PEXPIREAT key unix-time-milliseconds
```

## 判定key是否过期

Redis通过维护一个过期字典，用来判定某个键值对是否已过期。每当我们设置一个带过期时间的键值对，Redis都会将该key维护到过期字典中。

过期字典数据结构如下:

```c
typedef struct redisDb {
    dict *dict;    /* 数据库键空间，存放着所有的键值对 */
    dict *expires; /* 键的过期时间 */
    ....
} redisDb;
```

过期字典实际上是一个哈希表，好处是能够实现时间复杂度为O(1)的快速查询，每当我们查询一个键值对时，Redis首先会检查该key是否存在于过期字典中：

- 如果不在，正常读取键值对；
- 如果存在，获取该键值对的过期时间，当过期时间小于当前系统时间时，判定为过期，否则正常读取键值对；

## 常见的过期删除策略有哪些？

### 定时删除

结合事件机制，在给某个key设置过期时间时，同时创建一个定时事件，当时间到达后触发事件，自动执行删除key操作。

- 优点：可以保证key在过期时间到达后被删除，尽快释放内存空间。
- 缺点：当过期键较多的情况下，会占用相当一部分CPU执行时间，当业务繁忙阶段，会对服务器吞吐量和响应时间造成一定影响。

### 惰性删除

惰性删除的做法是不主动删除key，每当访问某个key时，判断该key是否到达过期时间，如果到期则执行删除操作。

- 优点：每次访问时，才会检查key的过期时间，只会使用很少的系统资源。
- 缺点：如果存在大量已过期的key，且一直没有得到访问，则这些key就会一直存在于内存中，造成一定的内存资源浪费。

### 定期删除

定期删除的做法是，每隔一段时间**「随机」从数据库中取出一定数量的key进行检查，并删除其中已过期的key。**

- 优点：通过限制删除操作执行的时长和频率，减少对CPU的影响，同时也能删除一部分过期的键值对，减少内存资源的浪费。
- 缺点：难以确定删除的频率，如果执行的太频繁，则会变得跟定期删除一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。

## Redis的过期淘汰策略是什么？

Redis选择「惰性删除+定期删除」这两种策略进行配合使用，用于在合理使用CPU资源和避免内存资源浪费之间取得平衡。

> **Redis**是怎么实现惰性删除的？
>

```c
int expireIfNeeded(redisDb *db, robj *key) {
    // 判断 key 是否过期
    if (!keyIsExpired(db,key)) return 0;
    ....
    /* 删除过期键 */
    ....
    // 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；
    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
                                         dbSyncDelete(db,key);
}
```

Redis在访问或更新某个key时，都会调用expireIfNeeded方法对其进行检查：

- 如果过期，则根据 **lazyfree_lazy_expire 参数决定选择异步删除还是同步删除，然后返回null给客户端。**
- 如果没有过期，则不做处理并正常返回。

> Redis是怎么实现定期删除的？
>
1. 间隔时长

   在Redis中，默认每10秒在过期字典中，抽取一定数量的key进行过期检查。

2. 随机抽查的数量

   其中随机抽查的数量是由 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 定义的，它是写死在代码中的，数值是 20。

    ```c
    do {
        //已过期的数量
        expired = 0；
        //随机抽取的数量
        num = 20;
        while (num--) {
            //1. 从过期字典中随机抽取 1 个 key
            //2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++
        }
        
        // 超过时间限制则退出
        if (timelimit_exit) return;
    
      /* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */
    } while (expired > 20/4);
    ```

    - 从过期字典中随机抽取20个key；
    - 检查这20个key是否已过期，并删除过期的key，
    - 如果本轮检查的已过期key数量大于总数的25%，且没有超过时间限制，继续重复步骤1，否则停止操作，等待下一轮抽查。

# 内存淘汰策略

前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。

## 如何设置Redis最大运行内存？

在配置文件 redis.conf 中，可以通过参数 `maxmemory <bytes>` 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。

## Redis内存淘汰策略有哪些？

Redis4.0之前一共有6种内存淘汰策略，在4.0之后，又增加了2种策略。

![](/images/posts/redis/01.png)

1. 不进行数据淘汰
    1. **noevication**

       默认情况下，Redis在使用的内存空间超过maxmomory阈值时，并不会进行数据淘汰，也就是设定的noevication策略。

2. 在设置了过期时间的数据中进行数据淘汰
    1. **volatile-random**

       在设置了过期时间的键值对中，进行随机删除。

    2. **volatile-ttl**

       在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后顺序进行删除，越早过期的越先被删除。

    3. **volatile-lru**

       使用 lru算法筛选设置了过期时间的键值对。

    4. **volatile-lfu** （Redis4.0后新增）

       使用 lfu算法筛选设置了过期时间的键值对。

3. 在所有数据范围内进行数据淘汰
    1. **allkeys-lru**

       使用 lru算法在所有数据中进行筛选。

    2. **allkeys-random**

       从所有键值对中随机选择并删除数据。

    3. **allkeys-lfu**（Redis4.0后新增）

       使用 lfu算法在所有数据中进行筛选。



## LRU算法和LFU算法有什么区别？

### LRU缓存策略

1. LRU缓存策略按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。
2. Redis默认会记录每个数据的最近一次访问时间戳（由键值对数据结构的RedisObject中的lru字段记录）。然后，Redis在决定淘汰数据时，第一次会随机选出N个数据，作为一个候选集合，然后比较候选集合中的lru值，把 lru字段值最小的数据从缓存中淘汰出去。

### LFU缓存策略

1. LFU缓存策略是在LRU策略基础上，为每个数据增加一个计数器，用以统计数据的访问次数。当使用LFU缓存策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出去。如果两个数据的访问次数相同，LFU策略再比较两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出去。
2. LFU策略实现的计数规则是：每当数据被访问一次，首先用计数器当前的值乘以配置项 lfu_log_factor 再加上1，取倒数，得到一个p值，然后把这个p值和一个取值范围在（0，1）间的随机数r值比较，只有p值大于r值时，计数器才加1。